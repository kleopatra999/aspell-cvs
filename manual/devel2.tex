%% LyX 1.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[11pt,english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\IfFileExists{url.sty}{\usepackage{url}}
                      {\newcommand{\url}{\texttt}}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 \newenvironment{lyxcode}
   {\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.

\usepackage[T1]{fontenc}
\usepackage{xspace}
\newcommand{\nach}{$\to$\xspace}
\newcommand{\hoch}{\texttt{$^\wedge$}}

\usepackage{html}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{enumerate}

\newcommand{\doubledash}{-\hspace{0.1em}-}
\newcommand{\doubledashb}{-\/-}
\newcommand{\dlt}{{\footnotesize$\ll$}}
\newcommand{\dgt}{{\footnotesize$\gg$}}

\begin{htmlonly}

\renewenvironment{lyxcode}
  {\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \ttfamily}%
   \item[] 
   \begin{ttfamily}}
   {\end{ttfamily}
    \end{list} }

\newenvironment{LyXParagraphIndent}[1]%
{\begin{quote}}
{\end{quote}}

\renewcommand{\LyX}{LyX}

\renewcommand{\doubledash}{\rawhtml &#45;&#45;\endrawhtml}
\renewcommand{\doubledashb}{\rawhtml &#45;&#45;\endrawhtml}
\renewcommand{\dlt}{«}
\renewcommand{\dgt}{»}

\renewcommand{\nach}{\rawhtml <i>to</i> \endrawhtml}
\renewcommand{\hoch}{\rawhtml &#94;\endrawhtml}

\end{htmlonly}

\makeatother
\begin{document}

\title{Aspell Devel Docs}


\author{Copyright (c) 2002\\
Kevin Atkinson\\
kevina@gnu.org}

\maketitle
\tableofcontents{}


\section*{Notes}

This manual is designed for those who which to developer Aspell. It
is currently very sketchy. However, it should improve over time. The
latest version of this document can be found at \url{http://savannah.gnu.org/download/aspell/manual/devel/devel.html}.

The eventual goal is to convert this manual into Texinfo. However,
since I do not have the time to learn Texinfo right now, I decided
to use something I am already conferable with. Once someone goes through
the trouble of converting it into Texinfo I will maintain the Texinfo
version.


\section*{Copyright}

Copyright (c) 2002 Kevin Atkinson. Permission is granted to copy,
distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.1 or any later version published
by the Free Software Foundation; with no Invariant Sections, no Front-Cover
Texts. and no Back-Cover Texts. A copy of the license is included
in the section entitled \char`\"{}GNU Free Documentation License\char`\"{}.


\section{Style Guidelines}

As far as coding styles go I am really not that picky. The important
thing is to stay consistent. However, please what ever you do, do
not indent with more than 4 characters as I find indenting with more
than that extremely difficult to read as most of the code ends up
on the right side of the window.


\section{Howto submit a patch\label{sec:hosto_submitt_a_patch}}
Coming or removed soooooooon.


\section{C++ Standard Library}

The C++ Standard library is not used directly except under very specific
circumstances. The string class and the STL is used indirectly though
wrapper classes and all I/O is done using the standard C library with
light right helper classes to make using C I/O a bit more C++ like.

However the new, new{[}{]}, delete and delete{[}{]} operates are used
to allocated memory when appropriate.


\section{Templates}

Templates are used in Aspell when there is a clear advantage to doing
so. When ever you use templates please use them carefully and try
very hard not to create code bloat by generating a lot of unnecessary,
and duplicate code.


\section{Error Handling}

Exceptions are not used in Aspell as I find them more trouble than
they are worth. Instead an alternate method of error handling is used
which is based around the PosibErr class. PosibErr is a special Error
handling device that will make sure that an error is properly handled.
It is defined in {}``posib\_err.hpp''. PosibErr is expected to be
used as the return type of the function It will automatically convert
to the \char`\"{}normal\char`\"{} return type however if the normal
returned type is accessed and there is an \char`\"{}unhandled\char`\"{}
error condition it will abort It will also abort if the object is
destroyed with an \char`\"{}unhandled\char`\"{} error condition. This
includes ignoring the return type of a function returning an error
condition. An error condition is handled by simply checking for the
presence of an error, calling ignore, or taking ownership of the error.

The PosibErr class is used extensively though out Aspell. Please refer
to the Aspell source for examples of using PosibErr until better documentation
is written.


\section{Source Code Layout }

\begin{description}
\item [common/]Common code used by all parts of Aspell
\item [lib/]Library code used only by the actual Aspell library
\item [data/]Data files used by Aspell
\item [modules/]Aspell modules which are eventually meant to be pluggable

\begin{description}
\item [speller/]~

\begin{description}
\item [default/]Main speller Module.
\end{description}
\item [filter/]~
\item [tokenizer/]~
\end{description}
\item [auto/]Scripts and data files to automatically generate code used
by Aspell
\item [interface/]Header files and such that external programs should use
when in order to use the Aspell library.

\begin{description}
\item [cc/]The external {}``C'' interface that programs should be using
when they wish to use Aspell.
\end{description}
\item [prog/]Actual programs based on the Aspell library. The main {}``aspell''
utility is included here.
\item [scripts/]Misc. scripts used by Aspell
\item [manual/]~
\item [examples/]Example programs demonstrating the use of the Aspell library
\end{description}

\section{Strings}


\subsection{String}

The String class provided the same functionally of the C++ string
except for fewer constructors. It also inherits OStream so that you
can write to it with the {}``<\/<'' operator. It is defined in {}``string.hpp''.


\subsection{ParmString}

ParmString is a special string class that is designed to be used as
a parameter for a function that is expecting a string. It is defined
in {}``parm\_sting.hpp''. It will allow either a \char`\"{}const
char {*}\char`\"{} or \char`\"{}String\char`\"{} class to be passed
in. It will automatically convert to a \char`\"{}const char {*}\char`\"{}.
The string can also be accesses via the \char`\"{}str\char`\"{} method.
Usage example:

\begin{lyxcode}
void~foo(ParmString~s1,~ParmString~s2)~\{~\\
~~~const~char~{*}~str0~=~s1;~\\
~~~unsigned~int~size0~=~s2.size()~\\
~~~if~(s1~==~s2~||~s2~==~\char`\"{}bar\char`\"{})~\{~\\
~~~~~...~\\
~~~\}~\\
\}~\\
...~\\
String~s1~=~\char`\"{}...\char`\"{};~\\
foo(s1);~\\
const~char~{*}~s2~=~\char`\"{}...\char`\"{};~\\
foo(s2);
\end{lyxcode}
This class should be used when a string is being passed in as a parameter.
It is faster than using {}``const String \&'' (as that will create
an unnecessary temporary when a const char {*} is passed in), and
is less annoying than using {}``const char {*}'' (as it doesn't
require the c\_str() method to be used when a String is passed in).


\subsection{CharVector}

A character vector is basically a Vector<char> but it has a few additional
methods for dealing with strings which Vector does not provide. It,
like String, is also inherits OStream so that you can write to it
with the {}``<\/<'' operator. It is defined in {}``char\_vector.hpp''.
Use it when ever you need a string which is guaranteed to be in a
continuous block of memory which you can write to.


\section{Smart Pointers}

Smart pointers are used extensively in Aspell to avoid simplify memory
management tasks and to avoid memory leaks.


\subsection{CopyPtr}

The CopyPtr class makes a deep copy of an object when ever it is copied.
The CopyPtr class is defined in {}``copy\_ptr.hpp''. This header
should be included where ever CopyPtr is used. The complete definition
of the object CopyPtr is pointing to does not need to be defined at
this point. The implementation is defined in {}``copy\_ptr-t.hpp''.
The implementation header file should be included at a point in your
code where the class CopyPtr is pointing to is completely defined.


\subsection{ClonePtr}

ClonePtr is like copy pointer except the clone() method is used instead
of the copy constructor to make copies of an object. If is defined
in {}``clone\_ptr.hpp'' and implemented in {}``clone\_ptr-t.hpp''.


\subsection{StackPtr}

A StackPtr is designed to be used when ever the only pointer to a
new object allocated with \textbf{new} is on the stack. It is similar
to the standard C++ auto\_ptr but the semantics are a bit different.
It is defined in {}``stack\_ptr.hpp'' unlike CopyPtr of ClonePtr
it is defined and implemented in this header file.


\subsection{GenericCopyPtr}

A generalized version of CopyPtr and ClonePtr which the two are based
on. It is defined in {}``generic\_copy\_ptr.hpp'' and implemented
in {}``generic\_copy\_ptr-t.hpp''.


\section{I/O}

Aspell does not use C++ I/O classes and function in any way since
they do not provide a way to get at the underlying file number and
can often be slower than the highly tuned C I/O functions found in
the standard C library. However, some light weight wrapper classes
are provided so that standard C I/O can be used in a more C++ like
way.


\subsection{IStream/OStream}

These two base classes mimic some of the functionally of the C++ functionally
of the corresponding classes. They are defined in {}``istream.hpp''
and {}``ostream.hpp'' respectfully. They are however based on standard
C I/O and are not proper C++ streams.


\subsection{FStream}

Defined in {}``fstream.hpp''


\subsection{Standard Streams}

CIN/COUT/CERR. Defined in {}``iostream.hpp''.


\section{Config Class}

The Config class is used to hold configuration information. It has
a set of keys which it will except. Inserting or even trying to look
at a key that it does not know will produce an error. It is defined
in {}``common/config.hpp''


\section{Filter Interface}


\subsection{Overview\label{sec:filter_overview}}

In Aspell there are 5 types of filters:

\begin{enumerate}
\item \textbf{Decoders} which take input in some standard format such as
iso8859-1 or UTF-8 and convert it into a string of FilterChars.
\item \textbf{Decoding filters} which manipulates a string of FilterChars
by decoding the text is some way such as converting SGML character
into its Unicode value. 
\item \textbf{True filters} which manipulates a string of FilterChars to
make it more suitable for spell checking. These filers generally blank
out text which should not be spell checked
\item \textbf{Encoding filters} which manipulates a string of FilterChars
by encoding the text is some way such as converting certain Unicode
characters to SGML characters.
\item \textbf{Encoders} which take a string of FilterChars and convert into
a standard format such as iso8859-1 or UTF-8
\end{enumerate}
Which types of filters are used depends on the situation

\begin{enumerate}
\item When \textbf{decoding words} for spell checking:

\begin{itemize}
\item The \textbf{decoder} to convert from a standard format
\item The \textbf{decoding filter} to perform high level decoding if necessary
\item The \textbf{encoder} to convert into an internal format used by the
speller module
\end{itemize}
\end{enumerate}
\begin{itemize}
\item When \textbf{checking a document}

\begin{itemize}
\item The \textbf{decoder} to convert from a standard format
\item The \textbf{decoding filter} to perform high level decoding if necessary
\item A \textbf{true filter} to filter out parts of the document which should
not be spell checked
\item The \textbf{encoder} to convert into an internal format used by the
speller module
\end{itemize}
\end{itemize}
\begin{enumerate}
\item When \textbf{encoding words} such as those returned for suggestions:

\begin{itemize}
\item The \textbf{decoder} to convert from the internal format used by the
speller module
\item The \textbf{encoding filter} to perform high level encodings if necessary
\item The \textbf{encoder} to convert into a standard format
\end{itemize}
\end{enumerate}
A FilterChar is a struct defined in {}``common/filter\_char.hpp''
which contains two members, a character, and a width. Its purpose
is to keep track of the width of the character in the original format.
This is important because when a misspelled word is found the exact
location of the word needs to be returned to the application so that
it can highlight it for the user. For example if the filters translated
this:

\begin{lyxcode}
Mr.~foo~said~\&quot;I~hate~my~namme\&quot;.
\end{lyxcode}
to this

\begin{lyxcode}
Mr.~foo~said~\char`\"{}I~hate~my~namme\char`\"{}.
\end{lyxcode}
without keeping track of the original width of the characters the
application will likely highlight {}``e my '' as the misspelling
because the spell checker will return 25 as the offset instead of
30. However with keeping track of the width using FilterChar the spell
checker will know that the real position it 30 since the quote is really
6 characters wide. In particular the text will be annotated something
like the following:

\begin{lyxcode}
1111111111111611111111111111161~\\
Mr.~foo~said~\char`\"{}I~hate~my~namme\char`\"{}.
\end{lyxcode}
The standard \textbf{encoder} and \textbf{decoder} filters are defined
in {}``common/convert.cpp''. There should generally not be any need
to deal with them so they will not be discussed here. The other three
filters, the \textbf{encoding filter}, the \textbf{true filter}, and
the \textbf{decoding filter}, are all defined the exact same way;
they are inherited from the IndividualFilter class.


\subsection{Adding a New Filter}

A new filter basically is added by placing the corresponding loadable object inside a directory reachable by Aspell via filter-path list.
Further it is necessary that the corresponding filter description file is located in one of the directories listed by the option-path list.

The name of the loadable object has to confirm the following convention \verb#lib<filtername>-filter.so#.
Where <\,{}filtername\,{}> stands for the name of the filter which is passed to Aspell by add-filter option.
The same applies to the filter description file which has to confirm the following naming scheme: \verb#<filtername>-filter.opt#.

Another way to supply a new filter is to reassemble existing filters to a new filter.
This is done by placing all necessary add-filter commands and corresponding option settings in a file called \verb#<filtername>.flt#.
For file placement the same rules apply as for a filter contained in a loadable object.
Filters assembled by .flt files do not have a corresponding .opt file.

To add a new loadable filter object create a new file. 
Basically the file should be a C++ file and end in {}``.cpp''.
The file should contain a new filter class inherited from IndividualFilter and a consturctor function  called \verb#new_<filtertype>#  (section \ref{sec:contstructor_function}) returning a new filter object.
Further it is necessary to manually generate the filter description file.
Finally the resulting object has to be turned into a loadable filter object using libtool.


\subsection{IndividualFilter class}

All filters are required to inherit from the IndividualFilter class
found in {}``indiv\_filter.hpp''. See that file for more details
and the other filter modules for examples of how it is used.


\subsection{Constructor Function \label{sec:contstructor_function}}

After the class is created a function must be created which will return
a new filter allocated with \textbf{new}. The function must have the
following prototype:

\begin{lyxcode}
IndividualFilter~{*}~new\_<\,{}<filtertype>\,{}>
\end{lyxcode}
Filters are defined in groups where each group contains an \textbf{encoding filter}, a \textbf{true filter}, and a \textbf{decoding filter} (section \ref{sec:filter_overview}).
Only one of them is required to be defined, however they all need a separate constructor function.

Instead of coding the constructor function(s)  manually it is more convenient to use the following macros\footnote{recommended, if filter is added to Aspell standard distribution}:
\begin{lyxcode}
ACTIVATE\_ENCODER\,(\,nspace\,{},\,class\_name\,{},\,filter\,)\\
ACTIVATE\_FILTER\,(\,nspace\,{},\,class\_name\,{},\,filter\,)\\
ACTIVATE\_DECODER\,(\,nspace\,{},\,class\_name\,{},\,filter\,)
\end{lyxcode}
They are provided by ``loadable\_filteAPI.hpp'' file (section \ref{sec:programmers_interface}).
These macros hide details about differences concerning the naming of the constructor function when statically linking the filter to Aspell instead of turning it into a loadable object.


\subsection{Filter Description File\label{sec:filter_descript}}

This file contains the description of a filter which is loaded by Aspell immediately when add-filter option is invoked.
If this file is missing Aspell will complain about it.
It consists of lines containing commentaries which must be started by a \verb'#' character and lines containing key value pairs describing the filter.
Each file at least has to contain the following to lines in the given order.
\begin{verbatim}
ASPELL >=0.51
DESCRIPTION this\ is\ short\ filter\ description
\end{verbatim}
The first non blank, non comment line has to contain the keyword \texttt{ASPELL} followed by the version of Aspell which the filter is usable with.
To denote multiple Aspell versions the version number may be prefixed by \textbf{<}, \textbf{<=}, \textbf{=}, \textbf{>=} or \textbf{>}.
If the range prefix is omitted \textbf{=} is assumed.
The line containing the \texttt{DESCRIPTION} of the filter may float freely in the description file unless it occurs inside a description of an option.
Whitespaces which occur inside the descriptive text have to escaped by \verb#\# character.
The keyword \texttt{DESCRIPTION} may be abbreviated by \texttt{DESC}.

If the filter description contains the following line
\begin{verbatim}
ENDFILE
\end{verbatim}
than Aspell will assume end of file and ignore all following line.
The same occurs implicitly if the real end of file is reached.

For each filter feature (see section \ref{sec:filter_overview}) the corresponding loadable object provides the option file has to provide the following line:
\begin{verbatim}
STATIC <filtertype>
\end{verbatim}
<filtertype> stands for one of \verb#encoder#, \verb#filter# or \verb#encoder# denoting the entire filter type.
This line allows to statically\footnote{see Section\ref{sec:link_filters_static}} link the filter into \texttt{Aspell} if requested by user or by system \texttt{Aspell} is built for.  


\begin{verbatim}
OPTION newoption
DESCRIPTION this\ is\ a\ short\ description\ of\ newoption
TYPE bool
DEFAULT false
ENDOPTION
\end{verbatim}
An option is added by a line containing the keyword \texttt{OPTION} followed by the name of the option.
If this name is not prefixed by the name of the filter \texttt{Aspell} will implicitly prefix it.
For the \texttt{DESCRIPTION} of a filter option the same holds as for the filter description.
The \texttt{TYPE} of the option may be one of \textbf{bool}, \textbf{int}, \textbf{string} or \textbf{list}.
If the \texttt{TYPE} is omitted \textbf{bool} is assumed. 
The default value(s) for an option is specified via \texttt{DEFAULT} (short \texttt{DEF}) followed by the desired \texttt{TYPE} dependent default value.
The table \ref{tab:filter_default_values} shows the possible values for each \texttt{TYPE}.
\begin{table}[hbt]
\centering
\begin{tabular}{l|l|l}
Type&default&available\\\hline
bool&true&true false\\\hline
int&0&any number value\\\hline
string&&any printable string\\\hline
list&&any comma separated list of strings\\\hline
\end{tabular}
\caption{The default values Aspell assumes if option description lacks a \texttt{DEFAULT} or \texttt{DEF} line.}
\label{tab:filter_default_values}
\end{table}
The \texttt{ENDOPTION} line may be omitted as it is assumed implicitly if a line containing \texttt{OPTION}, \texttt{STATIC} or \texttt{ENDFILE} keyword occurs or the file ends.

\paragraph{\small{}Note:}\small{}%
The keywords in a filter description file are case insensitive. The above examples use the all uppercase for better distinguishing them from values and comments.
Further a filter description may contain blank lines to enhance their readability.
\normalsize
\paragraph{\small{}Note:}\small{}%
An option of \textbf{list} type may contain multiple consecutive lines for default values starting with \texttt{DEFAULT} or \texttt{DEF}, to specify numerous default values.
\normalsize

\subsection{Retrieve Options by a filter}
An option always has to be retrieved by a filter using its full qualified name as the following example shows.
\begin{lyxcode}
  config->retrieve\_bool("filter-<\,{}<filtername>\,{}>-newoption");
\end{lyxcode}
The prefix ``filter-'' allows user to relate option uniquely to the specific filter when \verb#<filtername>-newoption# ambiguates an existing option of Aspell.
The \verb#<filtername># stands for the name of the filter the option belongs to and \verb#-newoption# is the name of the option as specified in the corresponding .opt file (see section \ref{sec:filter_descript}).
 

\subsection{Compiling and Linking}
See a good book on Unix programming on how to turn the filter source into a loadable object.

\subsection[Programmers Interface]{Programmers Interface\textsuperscript{\ref{fn:recommended_statndard_aspell}}\label{sec:programmers_interface}}

A more convenient way\footnote{\label{fn:recommended_statndard_aspell}recommended, if filter is added to Aspell standard distribution} to build a new filter is provided by Aspell's programmers interface for filter.
It is provided by the ``loadable-filter-API.hpp'' file.
Including this file gives access to a collection of macros hiding nasty details about runtime construction of a filter and about filter debugging.
Table \ref{tab:interface_macros} shows the macros provided by the interface.
For details upon the entire macros see loadable-filter-API.hpp\,{}.
An example upon how to use these macros can be found at examples/loadable/ccpp-context.hpp and examples/loadable/ccpp-context.cpp.
\begin{table}[htb]
\hspace{-.1\linewidth}
\begin{minipage}{1.1\linewidth}
\begin{tabular}{p{.33\textwidth}|p{.05\textwidth}|p{.3\textwidth}|p{.3\textwidth}}
\hline\hline
Macro&Type&Description&Notes\\\hline\hline
ACTIVATE\_ENCODER&\multirow{3}{.05\textwidth}[-1cm]{\rotatebox{90}{mandatory}}&makes the entire encoding filter callable by Aspell&\multirow{3}{.3\textwidth}{do not call inside class declaration; these macros define new\_<filtertype> function;}\\\cline{1-1}\cline{3-3}
ACTIVATE\_DECODER&&makes the entire decoding filter callable by Aspell&\\\cline{1-1}\cline{3-3}
ACTIVATE\_FILTER&&makes the entire filter callable by Aspell&\\\hline\hline
FDEBUGOPEN&\multirow{3}{.05\textwidth}[-1cm]{\rotatebox{90}{debugging}}&Initialises the macros for debugging a filter and opens the debug file stream&\multirow{3}{.3\textwidth}{These macros are only active if the {FILTER\_PRO\-GRESS\_CON\-TROL} macro is defined and denotes the name of the file debug messages should be sent to.
If debugging should go to Aspell standard debugging output \footnote{right now stderr} use empty string constant as filename}\\\cline{1-1}\cline{3-3}
FDEBUGCLOSE&&closes the debugging device opened by ``FDEBUGOPEN'' and reverts it to ``stderr'';&\\\cline{1-1}\cline{3-3}
FDEBUG&&prints the filename and the line number it occurs&\\\cline{1-1}\cline{3-3}
FDEBUGPRINTF&&special printf for debugging; if more than one argument is passed enclose the argument list by \verb#(# and \verb#)#;&\\\hline\hline
\end{tabular}
\end{minipage}
\caption{Macros provided by loadable-filter-API.hpp}
\label{tab:interface_macros}
\end{table}

\subsection{Adding filter to \texttt{Aspell} standard distribution\label{sec:link_filters_static}}
\paragraph{}
Any filter which one day should be added to \texttt{Aspell} has to be built using the developer interface, described in section \ref{sec:programmers_interface}.
To add the filter the following steps have to be performed:
\begin{enumerate}[1)]
\item
Decide whether the filter should be kept loadable if possible, or always be statically linked to \texttt{Aspell}.
\item\label{itm:place_sources}
Place the filter sources inside the entire directory of \texttt{Aspell} source tree.
Right now use \verb#$top_srcdir/modules/filter#.
\item
Modify the \verb#Makefile.am# file on the topmost directory of the Aspell distribution.
Follow the instructions given by the \verb+#Filter Modules+ section.
\item
Run \texttt{autoconf}, \texttt{automake}, \texttt{...}
\item
Reconfigure sources.
\item\label{itm:build_sources}
clear away any remains of a previous build and rebuild sources.
\item\label{itm:reinstall_aspell}
Reinstall \texttt{Aspell}.
\item\label{itm:test_filter_installed}
Test if filter has been added properly otherwise return to steps \ref{itm:place_sources}-\ref{itm:reinstall_aspell}.
\item
Reconfigure sources with \verb#enable-static# flag and repeat steps \ref{itm:build_sources}-\ref{itm:test_filter_installed} until your filter builds and runs properly in case of static linkage.
\item
Add your source files to \texttt{CVS}, and commit all your changes.
Or in case you are not allowed to commit to \texttt{CVS} than submit a patch\footnote{how to submit a patch see section\ref{sec:hosto_submitt_a_patch}} containing your changes. 
\end{enumerate} 

 
\section{Data Structures}

When ever possible you should try to use on of the data structures
available. If the data structures do not provide enough functionally
for your needs you should consider enhancing them rather than written
something from scratch.


\subsection{Vector}

The vector class is defined in {}``vector.hpp'' and works the same
way as the standard STL vector does except that it doesn't have as
many constructors.


\subsection{BasicList}

BasicList is a simple list structure which can either be implemented
as a singly or doubly linked list. It is defined in {}``basic\_list.hpp''.


\subsection{StringMap}

StringMap is a associative array for strings. You should try to use
this when ever possible to avoid code bloat. It is defined in {}``string\_map.hpp''


\subsection{Hash Tables}

Several hash tables are provided when StringMap is not appropriate.
These hash tables provide a hash\_set, hash\_multiset, hash\_map and
hash\_multimap which are very similar to SGI STL's implementation
with a few exceptions. It is defined in {}``hash.hpp''


\subsection{BlockSList}

BlockSList provided a pool of nodes which can be used for singly linked
lists. It is defined in {}``block\_slist.hpp''.


\section{Mk-Src Script}

A good deal of interface code is automatically generated by the {}``mk-src.pl''
Perl script. I am doing it this way to avoid having to write a lot
of relative code for the C++ interface. This should also make adding
interface for other languages a lot less tedious and will allow the
interface to automatically take advantage of new Aspell functionality
as it is made available. The {}``mk-src.pl'' script uses {}``mk-src.in''
as its input.

((MKSRC))

((FDL))
\end{document}
